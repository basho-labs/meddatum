#!/usr/bin/env escript




main([Server, Query0])->
    Self = self(),
    Pid = spawn_link(fun() -> consumer(Server, waiting, Self) end),
    ibrowse:start(),
    io:setopts([{encoding, unicode}]),
    UrlBase = io_lib:format("http://~s:8098/", [Server]),
    Query = (re:replace(Query0, "[\s]", "%20", [unicode,{return,list},global])),
    Params = "wt=json&q="++Query,
    Url = lists:flatten(UrlBase ++ "search/md_index?"++Params),
    io:format(standard_error, "sending query to ~p~n", [Url]),
    Res = ibrowse:send_req(Url, [], get),
    {ok, "200", _Header, Body} = Res,

    Json = jsonx:decode(unicode:characters_to_binary(Body), []),
    Response = get_property(<<"response">>, Json),
    Docs = get_property(<<"docs">>, Response),


                        
    MaxScore = get_property(<<"maxScore">>, Response),
    NumFound = get_property(<<"numFound">>, Response),
    Pid ! {start, NumFound, Docs},

    io:format(standard_error, "~p results found (max=~p).~n", [NumFound, MaxScore]),

    pagenate(Url, NumFound, length(Docs), Pid),
    
    %% io:format("~p~n", [Docs]),
    ibrowse:stop(),
    %% Result = riakc_pb_socket:search(C, <<"md_index">>, list_to_binary(Query)),
    %% io:format("~p~n", [Result]),
    receive done ->
            io:format(standard_error, "all data yeilded.~n", [])
    end.

pagenate(Url0, NumFound, Offset, Pid) ->
    Url = lists:flatten(Url0 ++ io_lib:format("&start=~p&rows=1024", [Offset])),
    {ok, "200", _Header, Body} = ibrowse:send_req(Url, [], get),

    Json = jsonx:decode(unicode:characters_to_binary(Body), []),
    Response = get_property(<<"response">>, Json),
    Docs = get_property(<<"docs">>, Response),
    if length(Docs) > 0 ->
            Pid ! {data, Docs},
            pagenate(Url0, NumFound, Offset+length(Docs), Pid);
       true ->
            ok
    end.

consumer(Server, waiting, Parent) ->
    {ok, C} = riakc_pb_socket:start_link(Server, 8087),
    receive
        {start, NumFound, Docs} ->
            io:format(standard_error, "start processing ~p/~p records found.~n",
                      [length(Docs), NumFound]),
            lists:foreach(fun(Doc) -> print_doc(C, Doc) end, Docs),
            consumer(C, {waiting, NumFound-length(Docs)}, Parent)
    end;
consumer(C, {waiting, Remain}, Parent) when Remain > 0 ->
    receive
        {data, Docs} ->
            io:format(standard_error, "processing ~p/~p records found.~n",
                      [length(Docs), Remain]),
            lists:foreach(fun(Doc) -> print_doc(C, Doc) end, Docs),
            consumer(C, {waiting, Remain-length(Docs)}, Parent)
    end;
consumer(C, {waiting, _}, Parent) ->
    %% done
    riakc_pb_socket:stop(C),
    Parent ! done.


get_property(Key, JsonxObject) ->
    {Proplist} = JsonxObject,
    proplists:get_value(Key, Proplist).

print_doc(C, Doc) ->
    B = get_property(<<"_yz_rb">>, Doc),
    K = get_property(<<"_yz_rk">>, Doc),
    {ok, RiakObj} = riakc_pb_socket:get(C, B, K),
    V = riakc_obj:get_value(RiakObj),
    io:format(standard_error, "[info] ~p ~p (~p bytes)~n", [B, K, byte_size(V)]),
    case unicode:characters_to_list(V, utf8) of
        E when is_tuple(E) ->
            {error, _, T} = E,
            io:format(standard_error, "error ~p~n", [binary_to_term(T)]),
            exit(E);
        String when is_list(String) ->
            io:put_chars(String),
            io:format("~n");
        Other ->
            io:format(standard_error, "unknown: ~p~n", [Other])

    end.
    
